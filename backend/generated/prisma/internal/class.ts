/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * Please import the `PrismaClient` class from the `client.ts` file instead.
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "./prismaNamespace"

const config: runtime.GetPrismaClientConfig = {
    previewFeatures: [],
    clientVersion: "7.2.0",
    engineVersion: "0c8ef2ce45c83248ab3df073180d5eda9e8be7a3",
    activeProvider: "postgresql",
    inlineSchema:
        'generator client {\n  provider = "prisma-client"\n  output   = "../generated/prisma"\n}\n\ndatasource db {\n  provider = "postgresql"\n}\n\n// ============================================\n// Better Auth Tables\n// ============================================\n\nmodel User {\n  id            String    @id @default(uuid())\n  email         String    @unique\n  emailVerified DateTime?\n  name          String?\n  image         String?\n  createdAt     DateTime  @default(now())\n  updatedAt     DateTime  @updatedAt\n\n  // Relations\n  accounts                 Account[]\n  sessions                 Session[]\n  sentMessages             Message[]\n  messageStatuses          MessageStatus[]\n  friendshipsAsUser1       Friendship[]              @relation("FriendshipUser1")\n  friendshipsAsUser2       Friendship[]              @relation("FriendshipUser2")\n  friendshipsRequested     Friendship[]              @relation("FriendshipRequester")\n  conversationParticipants ConversationParticipant[]\n}\n\nmodel Account {\n  id                String  @id @default(uuid())\n  userId            String\n  type              String\n  provider          String\n  providerAccountId String\n  refresh_token     String? @db.Text\n  access_token      String? @db.Text\n  expires_at        Int?\n  token_type        String?\n  scope             String?\n  id_token          String? @db.Text\n  session_state     String?\n\n  user User @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([provider, providerAccountId])\n  @@index([userId])\n}\n\nmodel Session {\n  id           String   @id @default(uuid())\n  sessionToken String   @unique\n  userId       String\n  expires      DateTime\n\n  user User @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@index([userId])\n}\n\nmodel Verification {\n  id         String   @id @default(uuid())\n  identifier String\n  token      String   @unique\n  expires    DateTime\n\n  @@unique([identifier, token])\n}\n\n// ============================================\n// Business Tables\n// ============================================\n\n// Friendship Management\nmodel Friendship {\n  id          String           @id @default(uuid())\n  userId1     String\n  userId2     String\n  status      FriendshipStatus @default(PENDING)\n  requestedBy String\n  createdAt   DateTime         @default(now())\n  updatedAt   DateTime         @updatedAt\n\n  user1     User @relation("FriendshipUser1", fields: [userId1], references: [id], onDelete: Cascade)\n  user2     User @relation("FriendshipUser2", fields: [userId2], references: [id], onDelete: Cascade)\n  requester User @relation("FriendshipRequester", fields: [requestedBy], references: [id], onDelete: Cascade)\n\n  @@unique([userId1, userId2])\n  @@index([userId1, status])\n  @@index([userId2, status])\n}\n\n// Conversation Management\nmodel Conversation {\n  id        String           @id @default(uuid())\n  type      ConversationType @default(ONE_TO_ONE)\n  createdAt DateTime         @default(now())\n\n  participants ConversationParticipant[]\n  messages     Message[]\n}\n\nmodel ConversationParticipant {\n  id             String    @id @default(uuid())\n  conversationId String\n  userId         String\n  joinedAt       DateTime  @default(now())\n  lastReadAt     DateTime?\n\n  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)\n  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([conversationId, userId])\n  @@index([userId])\n}\n\n// Message Management\nmodel Message {\n  id             String      @id @default(uuid())\n  conversationId String\n  senderId       String\n  content        String?     @db.Text\n  messageType    MessageType @default(TEXT)\n  imageUrl       String?\n  createdAt      DateTime    @default(now())\n\n  conversation Conversation    @relation(fields: [conversationId], references: [id], onDelete: Cascade)\n  sender       User            @relation(fields: [senderId], references: [id], onDelete: Cascade)\n  statuses     MessageStatus[]\n\n  @@index([conversationId, createdAt(sort: Desc)])\n}\n\nmodel MessageStatus {\n  id        String            @id @default(uuid())\n  messageId String\n  userId    String\n  status    MessageStatusType @default(SENT)\n  updatedAt DateTime          @updatedAt\n\n  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)\n  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([messageId, userId])\n  @@index([messageId])\n}\n\n// ============================================\n// Enums\n// ============================================\n\nenum FriendshipStatus {\n  PENDING\n  ACCEPTED\n  REJECTED\n}\n\nenum ConversationType {\n  ONE_TO_ONE\n  GROUP\n}\n\nenum MessageType {\n  TEXT\n  IMAGE\n}\n\nenum MessageStatusType {\n  SENT\n  DELIVERED\n  READ\n}\n',
    runtimeDataModel: {
        models: {},
        enums: {},
        types: {},
    },
}

config.runtimeDataModel = JSON.parse(
    '{"models":{"User":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"email","kind":"scalar","type":"String"},{"name":"emailVerified","kind":"scalar","type":"DateTime"},{"name":"name","kind":"scalar","type":"String"},{"name":"image","kind":"scalar","type":"String"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"},{"name":"accounts","kind":"object","type":"Account","relationName":"AccountToUser"},{"name":"sessions","kind":"object","type":"Session","relationName":"SessionToUser"},{"name":"sentMessages","kind":"object","type":"Message","relationName":"MessageToUser"},{"name":"messageStatuses","kind":"object","type":"MessageStatus","relationName":"MessageStatusToUser"},{"name":"friendshipsAsUser1","kind":"object","type":"Friendship","relationName":"FriendshipUser1"},{"name":"friendshipsAsUser2","kind":"object","type":"Friendship","relationName":"FriendshipUser2"},{"name":"friendshipsRequested","kind":"object","type":"Friendship","relationName":"FriendshipRequester"},{"name":"conversationParticipants","kind":"object","type":"ConversationParticipant","relationName":"ConversationParticipantToUser"}],"dbName":null},"Account":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"userId","kind":"scalar","type":"String"},{"name":"type","kind":"scalar","type":"String"},{"name":"provider","kind":"scalar","type":"String"},{"name":"providerAccountId","kind":"scalar","type":"String"},{"name":"refresh_token","kind":"scalar","type":"String"},{"name":"access_token","kind":"scalar","type":"String"},{"name":"expires_at","kind":"scalar","type":"Int"},{"name":"token_type","kind":"scalar","type":"String"},{"name":"scope","kind":"scalar","type":"String"},{"name":"id_token","kind":"scalar","type":"String"},{"name":"session_state","kind":"scalar","type":"String"},{"name":"user","kind":"object","type":"User","relationName":"AccountToUser"}],"dbName":null},"Session":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"sessionToken","kind":"scalar","type":"String"},{"name":"userId","kind":"scalar","type":"String"},{"name":"expires","kind":"scalar","type":"DateTime"},{"name":"user","kind":"object","type":"User","relationName":"SessionToUser"}],"dbName":null},"Verification":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"identifier","kind":"scalar","type":"String"},{"name":"token","kind":"scalar","type":"String"},{"name":"expires","kind":"scalar","type":"DateTime"}],"dbName":null},"Friendship":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"userId1","kind":"scalar","type":"String"},{"name":"userId2","kind":"scalar","type":"String"},{"name":"status","kind":"enum","type":"FriendshipStatus"},{"name":"requestedBy","kind":"scalar","type":"String"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"},{"name":"user1","kind":"object","type":"User","relationName":"FriendshipUser1"},{"name":"user2","kind":"object","type":"User","relationName":"FriendshipUser2"},{"name":"requester","kind":"object","type":"User","relationName":"FriendshipRequester"}],"dbName":null},"Conversation":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"type","kind":"enum","type":"ConversationType"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"participants","kind":"object","type":"ConversationParticipant","relationName":"ConversationToConversationParticipant"},{"name":"messages","kind":"object","type":"Message","relationName":"ConversationToMessage"}],"dbName":null},"ConversationParticipant":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"conversationId","kind":"scalar","type":"String"},{"name":"userId","kind":"scalar","type":"String"},{"name":"joinedAt","kind":"scalar","type":"DateTime"},{"name":"lastReadAt","kind":"scalar","type":"DateTime"},{"name":"conversation","kind":"object","type":"Conversation","relationName":"ConversationToConversationParticipant"},{"name":"user","kind":"object","type":"User","relationName":"ConversationParticipantToUser"}],"dbName":null},"Message":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"conversationId","kind":"scalar","type":"String"},{"name":"senderId","kind":"scalar","type":"String"},{"name":"content","kind":"scalar","type":"String"},{"name":"messageType","kind":"enum","type":"MessageType"},{"name":"imageUrl","kind":"scalar","type":"String"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"conversation","kind":"object","type":"Conversation","relationName":"ConversationToMessage"},{"name":"sender","kind":"object","type":"User","relationName":"MessageToUser"},{"name":"statuses","kind":"object","type":"MessageStatus","relationName":"MessageToMessageStatus"}],"dbName":null},"MessageStatus":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"messageId","kind":"scalar","type":"String"},{"name":"userId","kind":"scalar","type":"String"},{"name":"status","kind":"enum","type":"MessageStatusType"},{"name":"updatedAt","kind":"scalar","type":"DateTime"},{"name":"message","kind":"object","type":"Message","relationName":"MessageToMessageStatus"},{"name":"user","kind":"object","type":"User","relationName":"MessageStatusToUser"}],"dbName":null}},"enums":{},"types":{}}'
)

async function decodeBase64AsWasm(wasmBase64: string): Promise<WebAssembly.Module> {
    const { Buffer } = await import("node:buffer")
    const wasmArray = Buffer.from(wasmBase64, "base64")
    return new WebAssembly.Module(wasmArray)
}

config.compilerWasm = {
    getRuntime: async () => await import("@prisma/client/runtime/query_compiler_bg.postgresql.mjs"),

    getQueryCompilerWasmModule: async () => {
        const { wasm } =
            await import("@prisma/client/runtime/query_compiler_bg.postgresql.wasm-base64.mjs")
        return await decodeBase64AsWasm(wasm)
    },
}

export type LogOptions<ClientOptions extends Prisma.PrismaClientOptions> =
    "log" extends keyof ClientOptions
        ? ClientOptions["log"] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
            ? Prisma.GetEvents<ClientOptions["log"]>
            : never
        : never

export interface PrismaClientConstructor {
    /**
     * ## Prisma Client
     *
     * Type-safe database client for TypeScript
     * @example
     * ```
     * const prisma = new PrismaClient()
     * // Fetch zero or more Users
     * const users = await prisma.user.findMany()
     * ```
     *
     * Read more in our [docs](https://pris.ly/d/client).
     */

    new <
        Options extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
        LogOpts extends LogOptions<Options> = LogOptions<Options>,
        OmitOpts extends Prisma.PrismaClientOptions["omit"] = Options extends { omit: infer U }
            ? U
            : Prisma.PrismaClientOptions["omit"],
        ExtArgs extends runtime.Types.Extensions.InternalArgs =
            runtime.Types.Extensions.DefaultArgs,
    >(
        options: Prisma.Subset<Options, Prisma.PrismaClientOptions>
    ): PrismaClient<LogOpts, OmitOpts, ExtArgs>
}

/**
 * ## Prisma Client
 *
 * Type-safe database client for TypeScript
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */

export interface PrismaClient<
    in LogOpts extends Prisma.LogLevel = never,
    in out OmitOpts extends Prisma.PrismaClientOptions["omit"] = undefined,
    in out ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["other"] }

    $on<V extends LogOpts>(
        eventType: V,
        callback: (event: V extends "query" ? Prisma.QueryEvent : Prisma.LogEvent) => void
    ): PrismaClient

    /**
     * Connect with the database
     */
    $connect(): runtime.Types.Utils.JsPromise<void>

    /**
     * Disconnect from the database
     */
    $disconnect(): runtime.Types.Utils.JsPromise<void>

    /**
     * Executes a prepared raw query and returns the number of affected rows.
     * @example
     * ```
     * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
     * ```
     *
     * Read more in our [docs](https://pris.ly/d/raw-queries).
     */
    $executeRaw<T = unknown>(
        query: TemplateStringsArray | Prisma.Sql,
        ...values: any[]
    ): Prisma.PrismaPromise<number>

    /**
     * Executes a raw query and returns the number of affected rows.
     * Susceptible to SQL injections, see documentation.
     * @example
     * ```
     * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
     * ```
     *
     * Read more in our [docs](https://pris.ly/d/raw-queries).
     */
    $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>

    /**
     * Performs a prepared raw query and returns the `SELECT` data.
     * @example
     * ```
     * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
     * ```
     *
     * Read more in our [docs](https://pris.ly/d/raw-queries).
     */
    $queryRaw<T = unknown>(
        query: TemplateStringsArray | Prisma.Sql,
        ...values: any[]
    ): Prisma.PrismaPromise<T>

    /**
     * Performs a raw query and returns the `SELECT` data.
     * Susceptible to SQL injections, see documentation.
     * @example
     * ```
     * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
     * ```
     *
     * Read more in our [docs](https://pris.ly/d/raw-queries).
     */
    $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>

    /**
     * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
     * @example
     * ```
     * const [george, bob, alice] = await prisma.$transaction([
     *   prisma.user.create({ data: { name: 'George' } }),
     *   prisma.user.create({ data: { name: 'Bob' } }),
     *   prisma.user.create({ data: { name: 'Alice' } }),
     * ])
     * ```
     *
     * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
     */
    $transaction<P extends Prisma.PrismaPromise<any>[]>(
        arg: [...P],
        options?: { isolationLevel?: Prisma.TransactionIsolationLevel }
    ): runtime.Types.Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

    $transaction<R>(
        fn: (
            prisma: Omit<PrismaClient, runtime.ITXClientDenyList>
        ) => runtime.Types.Utils.JsPromise<R>,
        options?: {
            maxWait?: number
            timeout?: number
            isolationLevel?: Prisma.TransactionIsolationLevel
        }
    ): runtime.Types.Utils.JsPromise<R>

    $extends: runtime.Types.Extensions.ExtendsHook<
        "extends",
        Prisma.TypeMapCb<OmitOpts>,
        ExtArgs,
        runtime.Types.Utils.Call<
            Prisma.TypeMapCb<OmitOpts>,
            {
                extArgs: ExtArgs
            }
        >
    >

    /**
     * `prisma.user`: Exposes CRUD operations for the **User** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Users
     * const users = await prisma.user.findMany()
     * ```
     */
    get user(): Prisma.UserDelegate<ExtArgs, { omit: OmitOpts }>

    /**
     * `prisma.account`: Exposes CRUD operations for the **Account** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Accounts
     * const accounts = await prisma.account.findMany()
     * ```
     */
    get account(): Prisma.AccountDelegate<ExtArgs, { omit: OmitOpts }>

    /**
     * `prisma.session`: Exposes CRUD operations for the **Session** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Sessions
     * const sessions = await prisma.session.findMany()
     * ```
     */
    get session(): Prisma.SessionDelegate<ExtArgs, { omit: OmitOpts }>

    /**
     * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Verifications
     * const verifications = await prisma.verification.findMany()
     * ```
     */
    get verification(): Prisma.VerificationDelegate<ExtArgs, { omit: OmitOpts }>

    /**
     * `prisma.friendship`: Exposes CRUD operations for the **Friendship** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Friendships
     * const friendships = await prisma.friendship.findMany()
     * ```
     */
    get friendship(): Prisma.FriendshipDelegate<ExtArgs, { omit: OmitOpts }>

    /**
     * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Conversations
     * const conversations = await prisma.conversation.findMany()
     * ```
     */
    get conversation(): Prisma.ConversationDelegate<ExtArgs, { omit: OmitOpts }>

    /**
     * `prisma.conversationParticipant`: Exposes CRUD operations for the **ConversationParticipant** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more ConversationParticipants
     * const conversationParticipants = await prisma.conversationParticipant.findMany()
     * ```
     */
    get conversationParticipant(): Prisma.ConversationParticipantDelegate<
        ExtArgs,
        { omit: OmitOpts }
    >

    /**
     * `prisma.message`: Exposes CRUD operations for the **Message** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Messages
     * const messages = await prisma.message.findMany()
     * ```
     */
    get message(): Prisma.MessageDelegate<ExtArgs, { omit: OmitOpts }>

    /**
     * `prisma.messageStatus`: Exposes CRUD operations for the **MessageStatus** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more MessageStatuses
     * const messageStatuses = await prisma.messageStatus.findMany()
     * ```
     */
    get messageStatus(): Prisma.MessageStatusDelegate<ExtArgs, { omit: OmitOpts }>
}

export function getPrismaClientClass(): PrismaClientConstructor {
    return runtime.getPrismaClient(config) as unknown as PrismaClientConstructor
}
